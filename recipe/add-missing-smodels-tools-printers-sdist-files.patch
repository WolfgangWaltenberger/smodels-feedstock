From b4b03a5d51b2a055ba05fed66b8b2c2f42bd3028 Mon Sep 17 00:00:00 2001
From: Matthew Feickert <matthew.feickert@cern.ch>
Date: Tue, 11 Mar 2025 00:16:55 +0100
Subject: [PATCH] fix: Add missing smodels/tools/printers sdist files

* As the add-printers-to-packaging.patch only went in to v3.0.3 the
  smodels/tools/printers directory was never being added to the
  sdist when it was built and so the sdists are permanently broken.
  To fix this requires adding in all the missing files in a patch.
---
 smodels/tools/printers/__init__.py       |   5 +
 smodels/tools/printers/basicPrinter.py   | 164 ++++++++
 smodels/tools/printers/masterPrinter.py  | 108 +++++
 smodels/tools/printers/pythonPrinter.py  | 424 ++++++++++++++++++++
 smodels/tools/printers/slhaPrinter.py    | 234 +++++++++++
 smodels/tools/printers/summaryPrinter.py | 190 +++++++++
 smodels/tools/printers/txtPrinter.py     | 484 +++++++++++++++++++++++
 smodels/tools/printers/xmlPrinter.py     | 115 ++++++
 8 files changed, 1724 insertions(+)
 create mode 100644 smodels/tools/printers/__init__.py
 create mode 100644 smodels/tools/printers/basicPrinter.py
 create mode 100644 smodels/tools/printers/masterPrinter.py
 create mode 100644 smodels/tools/printers/pythonPrinter.py
 create mode 100644 smodels/tools/printers/slhaPrinter.py
 create mode 100644 smodels/tools/printers/summaryPrinter.py
 create mode 100644 smodels/tools/printers/txtPrinter.py
 create mode 100644 smodels/tools/printers/xmlPrinter.py

diff --git a/smodels/tools/printers/__init__.py b/smodels/tools/printers/__init__.py
new file mode 100644
index 000000000..1e109dacf
--- /dev/null
+++ b/smodels/tools/printers/__init__.py
@@ -0,0 +1,5 @@
+"""
+.. module:: tools.printers.__init__
+    :synopsis: This package contains tools for handling printers
+"""
+
diff --git a/smodels/tools/printers/basicPrinter.py b/smodels/tools/printers/basicPrinter.py
new file mode 100644
index 000000000..a6c95a61c
--- /dev/null
+++ b/smodels/tools/printers/basicPrinter.py
@@ -0,0 +1,164 @@
+"""
+.. module:: basicPrinter
+   :synopsis: Base class for defining printer classes
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+"""
+
+import sys
+import os
+from smodels.base.smodelsLogging import logger
+import numpy as np
+import time
+
+
+class BasicPrinter(object):
+    """
+    Super class to handle the basic printing methods
+    """
+
+    def __init__(self, output, filename, outputFormat = 'current'):
+        """
+        :ivar str typeofexpectedvalues: what type of expected values to print,
+              apriori or posteriori
+        """
+
+        self.name = "basic"
+        self.time = time.time()  # time stamps
+
+        self.outputList = []
+        self.filename = filename
+        self.output = output
+        self.printingOrder = []
+        self.typeofexpectedvalues = "apriori"
+        self.toPrint = []
+        self.outputFormat = outputFormat
+
+        if filename and os.path.isfile(filename):
+            logger.warning("Removing file %s" % filename)
+            os.remove(filename)
+
+    def getTypeOfExpected(self):
+        """ tiny convenience function for what expected values to print,
+            apriori (True) or posteriori """
+        expected = True
+        if self.typeofexpectedvalues == "posteriori":
+            expected = "posteriori"
+        return expected
+
+    @property
+    def filename(self):
+        return self._filename
+
+    @filename.setter
+    def filename(self, fn):
+        self._filename = fn
+        self.mkdir()
+
+    def mkdir(self):
+        """ create directory to file, if necessary """
+        if not self.filename:
+            return
+        dirname = os.path.dirname(self.filename)
+        if dirname != "" and not os.path.exists(dirname):
+            os.makedirs(dirname)
+
+    def setOptions(self, options):
+        """
+        Store the printer specific options to control the output of each printer.
+        Each option is stored as a printer attribute.
+
+        :param options: a list of (option,value) for the printer.
+        """
+
+        for opt, value in options:
+            setattr(self, opt, eval(value))
+
+    def addObj(self, obj):
+        """
+        Adds object to the Printer.
+
+        :param obj: A object to be printed. Must match one of the types defined in formatObj
+
+        :return: True if the object has been added to the output. If the object does not belong
+                to the pre-defined printing list toPrint, returns False.
+        """
+
+        for iobj, objType in enumerate(self.printingOrder):
+            if isinstance(obj, objType):
+                self.toPrint[iobj] = obj
+                return True
+        return False
+
+    def openOutFile(self, filename, mode):
+        """ creates and opens a data sink,
+            creates path if needed """
+        d = os.path.dirname(filename)
+        if not os.path.exists(d):
+            os.makedirs(d)
+            logger.info("creating directory %s" % d)
+        return open(filename, mode)
+
+    def flush(self):
+        """
+        Format the objects added to the output, print them to the screen
+        or file and remove them from the printer.
+        """
+        ret = ""
+
+        for obj in self.toPrint:
+            if obj is None:
+                continue
+            output = self._formatObj(obj)
+            if not output:
+                continue  # Skip empty output
+            ret += output
+            if self.output == 'stdout':
+                sys.stdout.write(output)
+            elif self.output == 'file':
+                if not self.filename:
+                    logger.error('Filename not defined for printer')
+                    return False
+                with self.openOutFile(self.filename, "a") as outfile:
+                    outfile.write(output)
+                    outfile.close()
+
+        self.toPrint = [None]*len(self.printingOrder)  # Reset printing objects
+        self.time = time.time()  # prepare next timestamp
+        return ret
+
+    def _formatObj(self, obj):
+        """
+        Method for formatting the output depending on the type of object
+        and output.
+
+        :param obj: A object to be printed. Must match one of the types defined in formatObj
+
+        """
+
+        typeStr = type(obj).__name__
+        try:
+            formatFunction = getattr(self, '_format'+typeStr)
+            ret = formatFunction(obj)
+            # print ( " `-", len(ret))
+            return ret
+        except AttributeError as e:
+            logger.warning('Error formating object %s: \n %s' % (typeStr, e))
+            return False
+
+    def _round(self, number, n=6):
+        """ round a number to n significant digits, if it *is* a number """
+        if type(number) not in [float, np.float64]:
+            return number
+        if not np.isfinite(number):
+            return f'float("{number}")'
+        if np.isnan(number) or not np.isfinite(number):
+            return number
+        try:
+            if abs(number) < 1e-40:
+                return number
+            return round(number, -int(np.floor(np.sign(number) * np.log10(abs(number)))) + n)
+        except Exception:
+            pass
+        return number
+        # return round ( number, n )
diff --git a/smodels/tools/printers/masterPrinter.py b/smodels/tools/printers/masterPrinter.py
new file mode 100644
index 000000000..f2c19b53b
--- /dev/null
+++ b/smodels/tools/printers/masterPrinter.py
@@ -0,0 +1,108 @@
+
+"""
+.. module:: masterPrinter
+   :synopsis: Class to handle the distinct printer formats
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+
+"""
+
+from smodels.base.smodelsLogging import logger
+from smodels.tools.printers.pythonPrinter import PyPrinter
+from smodels.tools.printers.xmlPrinter import XmlPrinter
+from smodels.tools.printers.summaryPrinter import SummaryPrinter
+from smodels.tools.printers.txtPrinter import TxTPrinter
+from smodels.tools.printers.slhaPrinter import SLHAPrinter
+
+
+class MPrinter(object):
+    """
+    Master Printer class to handle the Printers (one printer/output type)
+    """
+
+    def __init__(self):
+
+        self.name = "master"
+        self.Printers = {}
+        self.outputFormat = "current"
+
+    def setPrinterOptions(self, parser):
+        """
+        Define the printer types and their options.
+
+        :param parser: ConfigParser storing information from the parameters file
+        """
+
+        # Define the printer types and the printer-specific options:
+        printerTypes = [prt.strip() for prt in parser.get(
+            "printer", "outputType").split(",")]
+        if parser.has_option("printer","outputFormat"):
+            self.outputFormat = parser.get("printer","outputFormat")
+        for prt in printerTypes:
+            if prt == 'python':
+                newPrinter = PyPrinter(output='file', outputFormat=self.outputFormat)
+            elif prt == 'summary':
+                newPrinter = SummaryPrinter(output='file', outputFormat=self.outputFormat)
+            elif prt == 'stdout':
+                newPrinter = TxTPrinter(output='stdout', outputFormat=self.outputFormat)
+            elif prt == 'log':
+                newPrinter = TxTPrinter(output='file', outputFormat=self.outputFormat)
+            elif prt == 'xml':
+                newPrinter = XmlPrinter(output='file', outputFormat=self.outputFormat)
+            elif prt == 'slha':
+                newPrinter = SLHAPrinter(output='file', outputFormat=self.outputFormat)
+                if parser.getboolean("options", "doCompress") or parser.getboolean("options", "doInvisible"):
+                    newPrinter.docompress = 1
+                if parser.has_option("options", "combineSRs") and parser.getboolean("options", "combineSRs"):
+                    newPrinter.combinesr = 1
+                if parser.has_option("options", "combineAnas") and parser.get("options", "combineAnas"):
+                    newPrinter.combineanas = 1
+            else:
+                logger.warning("Unknown printer format: %s" % str(prt))
+                continue
+
+            # Copy stdout options to log options:
+            if 'log' in printerTypes:
+                if parser.has_section('stdout-printer') and not parser.has_section('log-printer'):
+                    parser.add_section('log-printer')
+                    for option, val in parser.items('stdout-printer'):
+                        parser.set('log-printer', option, val)
+
+            # Set printer-specific options:
+            if parser.has_section(prt+'-printer'):
+                newPrinter.setOptions(parser.items(prt+'-printer'))
+            self.Printers[prt] = newPrinter
+
+    def addObj(self, obj):
+        """
+        Adds the object to all its Printers:
+
+        :param obj: An object which can be handled by the Printers.
+        """
+
+        for prt in self.Printers.values():
+            prt.addObj(obj)
+
+    def setOutPutFiles(self, filename, silent=False):
+        """
+        Set the basename for the output files. Each printer will
+        use this file name appended of the respective extension
+        (i.e. .py for a python printer, .smodels for a summary printer,...)
+
+        :param filename: Input file name
+        :param silent: dont comment removing old files
+        """
+
+        for printer in self.Printers.values():
+            printer.setOutPutFile(filename, silent=silent)
+
+    def flush(self):
+        """
+        Ask all printers to write the output and clear their cache.
+        If the printers return anything other than None,
+        we pass it on.
+        """
+        ret = {}
+        for printerType, printer in self.Printers.items():
+            ret[printerType] = printer.flush()
+        return ret
diff --git a/smodels/tools/printers/pythonPrinter.py b/smodels/tools/printers/pythonPrinter.py
new file mode 100644
index 000000000..c1ad5d22a
--- /dev/null
+++ b/smodels/tools/printers/pythonPrinter.py
@@ -0,0 +1,424 @@
+"""
+.. module:: pythonPrinter
+   :synopsis: Class for describing a printer in python format
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+
+"""
+
+from __future__ import print_function
+import sys
+import os
+from smodels.decomposition.topologyDict import TopologyDict
+from smodels.matching.theoryPrediction import TheoryPredictionList,TheoryPrediction,TheoryPredictionsCombiner
+from smodels.tools.ioObjects import OutputStatus
+from smodels.tools.coverage import Uncovered
+from smodels.base.physicsUnits import GeV, fb, TeV
+from smodels.base.smodelsLogging import logger
+from smodels.tools.printers.basicPrinter import BasicPrinter
+from smodels.tools.printerTools import formatNestedDict
+from collections import OrderedDict
+import unum
+import time
+
+
+class PyPrinter(BasicPrinter):
+    """
+    Printer class to handle the printing of one single pythonic output
+    """
+
+    def __init__(self, output='stdout', filename=None, outputFormat='current'):
+        BasicPrinter.__init__(self, output, filename, outputFormat)
+        self.name = "py"
+        self.printtimespent = False
+        self.printingOrder = [OutputStatus, TopologyDict,
+                              TheoryPredictionList, TheoryPredictionsCombiner,
+                              TheoryPrediction, Uncovered]
+        self.toPrint = [None]*len(self.printingOrder)
+
+    def setOutPutFile(self, filename, overwrite=True, silent=False):
+        """
+        Set the basename for the text printer. The output filename will be
+        filename.py.
+        :param filename: Base filename
+        :param overwrite: If True and the file already exists, it will be removed.
+        :param silent: dont comment removing old files
+        """
+
+        self.filename = filename + '.py'
+        if overwrite and os.path.isfile(self.filename):
+            if not silent:
+                logger.warning("Removing old output file " + self.filename)
+            os.remove(self.filename)
+
+    def flush(self):
+        """
+        Write the python dictionaries generated by the object formatting
+        to the defined output
+        """
+
+        outputDict = {}
+        for obj in self.toPrint:
+            if obj is None:
+                continue
+            output = self._formatObj(obj)
+            if not output:
+                continue  # Skip empty output
+            outputDict.update(output)
+
+        output = 'smodelsOutput = ' + formatNestedDict(outputDict)
+        if self.output == 'stdout':
+            sys.stdout.write(output)
+        elif self.output == 'file':
+            if not self.filename:
+                logger.error('Filename not defined for printer')
+                return False
+            with open(self.filename, "a") as outfile:
+                outfile.write(output)
+                outfile.close()
+
+        self.toPrint = [None]*len(self.printingOrder)
+        # it is a special feature of the python printer
+        # that we also return the output dictionary
+        return outputDict
+
+    def _formatTopologyDict(self, obj):
+        """
+        Format data for a TopologyDict object.
+
+        :param obj: A TopologyDict object to be printed.
+        """
+
+        if not hasattr(self, 'addsmslist') or not self.addsmslist:
+            return None
+
+
+        smsList = []
+        for sms in obj.getSMSList():
+            smsList.append(self._formatSMS(sms))
+
+        if self.outputFormat == 'version2':
+            return {'Element' : smsList}
+        else:
+            return {"SMS Decomposition": smsList}
+
+    def _formatSMS(self, obj):
+        """
+        Format data for a SMS object.
+
+        :param obj: A SMS object to be printed.
+        """
+
+        smsDict = {}
+        if self.outputFormat == 'version2':
+            try:
+                branchList, finalState, _ = obj.treeToBrackets()
+                masses = []
+                pidlist = []
+                for bIndex in obj.daughterIndices(obj.rootIndex):
+                    branch = obj.indexToNode(bIndex)
+                    if branch.isSM:
+                        continue
+                    mass = float('%1.3e' %branch.mass.asNumber(GeV))
+                    bMasses = [mass]
+                    pids = [branch.pdg]
+                    for n in obj.dfsIndexIterator(bIndex):
+                        node = obj.indexToNode(n)
+                        if node.isSM:
+                            continue
+                        mass = float('%1.3e' %node.mass.asNumber(GeV))
+                        bMasses.append(mass)
+                        pids.append(node.pdg)
+                    masses.append(bMasses)
+                    pidlist.append(pids)
+
+                smsDict["ID"] = obj.smsID
+                smsDict["Particles"] =  str(branchList).replace("'","").replace(" ","")
+                smsDict["final states"] =  finalState
+                smsDict["Masses (GeV)"] = masses
+                smsDict["PIDs"] = pidlist
+            except:
+                logger.info("Could not format SMS using version2, switching to current format.")
+                self.outputFormat = 'current'
+
+        if self.outputFormat == 'current':
+            smsDict["ID"] = obj.smsID
+            smsDict["SMS"] = str(obj)
+            smsDict["Masses (GeV)"] = [(str(node),float('%1.3e' %node.mass.asNumber(GeV)))
+                                      for node in obj.nodes if not node.isSM]
+            smsDict["PIDs"] = [(str(node),node.pdg)
+                              for node in obj.nodes if not node.isSM]
+
+
+        smsDict["Weights (fb)"] = {}
+        sqrts = [info.sqrts.asNumber(TeV) for info in obj.weightList.getInfo()]
+        allsqrts = sorted(list(set(sqrts)))
+        for ssqrts in allsqrts:
+            sqrts = ssqrts * TeV
+            xsecs = [xsec.value.asNumber(fb)
+                     for xsec in obj.weightList.getXsecsFor(sqrts)]
+            if len(xsecs) != 1:
+                logger.warning("Cross section lists contain multiple values for %s .\
+                Only the first cross section will be printed" % str(sqrts))
+            xsecs = float('%1.2e' %xsecs[0])
+            sqrtsStr = 'xsec '+str(sqrts.asNumber(TeV))+' TeV'
+            smsDict["Weights (fb)"][sqrtsStr] = xsecs
+
+        return smsDict
+
+    def _formatOutputStatus(self, obj):
+        """
+        Format data for a OutputStatus object.
+
+        :param obj: A OutputStatus object to be printed.
+        """
+
+        infoDict = {}
+        for key, val in obj.parameters.items():
+            try:
+                infoDict[key] = eval(val)
+            except (NameError, TypeError, SyntaxError):
+                infoDict[key] = val
+        infoDict['file status'] = obj.filestatus
+        infoDict['decomposition status'] = obj.status
+        infoDict['warnings'] = obj.warnings
+        infoDict['input file'] = obj.inputfile
+        infoDict['database version'] = obj.databaseVersion
+        infoDict['smodels version'] = obj.smodelsVersion
+        # hidden feature, printtimespent, turn on in ini file, e.g.
+        # [summary-printer] printtimespent = True
+        if self.printtimespent:
+            infoDict['time spent'] = "%.2fs" % (time.time() - self.time)
+        return {'OutputStatus': infoDict}
+
+    def _formatTheoryPredictionList(self, obj):
+        """
+        Format data of the TheoryPredictionList object.
+
+        :param obj: A TheoryPredictionList object to be printed.
+        """
+        obj.sortTheoryPredictions()
+        ExptRes = []
+        for theoryPrediction in obj._theoryPredictions:
+            expResult = theoryPrediction.expResult
+            expID = expResult.globalInfo.id
+            datasetID = theoryPrediction.dataId()
+            dataType = theoryPrediction.dataType()
+            ul = theoryPrediction.getUpperLimit()
+            ulExpected = theoryPrediction.getUpperLimit(
+                expected=self.getTypeOfExpected())
+            if isinstance(ul, unum.Unum):
+                ul = ul.asNumber(fb)
+            if isinstance(ulExpected, unum.Unum):
+                ulExpected = ulExpected.asNumber(fb)
+
+            value = theoryPrediction.xsection.asNumber(fb)
+            txnamesDict = {}
+            for sms in theoryPrediction.smsList:
+                if sms.txname.txName not in txnamesDict:
+                    txnamesDict[sms.txname.txName] = sms.weight.asNumber(fb)
+                else:
+                    txnamesDict[sms.txname.txName] += sms.weight.asNumber(fb)
+            maxconds = theoryPrediction.getmaxCondition()
+
+            def _convWidth(x):
+                if type(x) == type(GeV):
+                    x = float(x.asNumber(GeV))
+                if x == float("inf"):
+                    x = "prompt"
+                if x == 0.:
+                    x = "stable"
+                return x
+
+            def roundme(x):
+                if type(x) == tuple:
+                    return (round(x[0].asNumber(GeV), 2), x[1].asNumber(GeV))
+                return round(x.asNumber(GeV), 2)
+
+            avgSMS = theoryPrediction.avgSMS
+            if avgSMS is None:  # There is no commong topology
+                mass = None
+                widths = None
+                nodesDict = None
+            elif self.outputFormat == "version2":
+                mass = []
+                widths = []
+                nodesDict = {}
+                for dIndex in avgSMS.daughterIndices(avgSMS.rootIndex):
+                    daughter = avgSMS.indexToNode(dIndex)
+                    mass.append([daughter.mass.asNumber(GeV)])
+                    widths.append([_convWidth(daughter.totalwidth)])
+                    for nodeIndex in avgSMS.dfsIndexIterator(dIndex):
+                        node = avgSMS.indexToNode(nodeIndex)
+                        if node.isSM:
+                            continue
+                        m = node.mass.asNumber(GeV)
+                        mass[-1].append(m)
+                        widths[-1].append(_convWidth(node.totalwidth))
+            else:
+                widthDict = {}
+                massDict = {}
+                for n in avgSMS.nodes:
+                    if n.isSM or n is avgSMS.root:
+                        continue
+                    massDict[str(n)] = n.mass.asNumber(GeV)
+                    widthDict[str(n)] = n.totalwidth.asNumber(GeV)
+                mass = [(k,v) for k,v in massDict.items()]
+                widths = [(k,_convWidth(v)) for k,v in widthDict.items()]
+
+                nodesDict = {nodeIndex : str(node) for nodeIndex,node
+                             in avgSMS._nodesMapping.items()}
+
+            sqrts = expResult.globalInfo.sqrts
+
+            r = self._round(theoryPrediction.getRValue(expected=False))
+            r_expected = self._round(theoryPrediction.getRValue(
+                expected=self.getTypeOfExpected()))
+
+            resDict = {'maxcond': maxconds, 'theory prediction (fb)': self._round(value),
+                       'upper limit (fb)': self._round(ul),
+                       'expected upper limit (fb)': self._round(ulExpected),
+                       'TxNames': sorted(txnamesDict.keys()),
+                       'Mass (GeV)': mass,
+                       'AnalysisID': expID,
+                       'DataSetID': datasetID,
+                       'AnalysisSqrts (TeV)': sqrts.asNumber(TeV),
+                       'lumi (fb-1)': (expResult.globalInfo.lumi*fb).asNumber(),
+                       'dataType': dataType,
+                       'r': r, 'r_expected': r_expected,
+                       'Width (GeV)' : widths}
+
+            if hasattr(self, "addtxweights") and self.addtxweights:
+                resDict['TxNames weights (fb)'] = txnamesDict
+            if hasattr(self, "addnodesmap") and self.addnodesmap:
+                resDict['Nodes Map'] = nodesDict
+
+            nll = theoryPrediction.likelihood( return_nll = True )
+            if nll is not None:
+                # resDict['chi2'] = self._round ( theoryPrediction.chi2 )
+                resDict['nll'] = self._round(nll)
+                resDict['nll_min'] = self._round(theoryPrediction.lmax(return_nll = True ))
+                resDict['nll_SM'] = self._round(theoryPrediction.lsm( return_nll = True ))
+            ExptRes.append(resDict)
+
+        return {'ExptRes': ExptRes}
+
+    def _formatDoc(self, obj):
+        """
+        Format a pyslha object to be printed as a dictionary
+
+        :param obj: pyslha object
+        """
+
+        MINPAR = dict(obj.blocks['MINPAR'].entries)
+        EXTPAR = dict(obj.blocks['EXTPAR'].entries)
+        mass = OrderedDict(obj.blocks['MASS'].entries.items())
+        chimix = {}
+        for key in obj.blocks['NMIX'].entries:
+            val = obj.blocks['NMIX'].entries[key]
+            if key[0] != 1:
+                continue
+            newkey = 'N'+str(key[0])+str(key[1])
+            chimix[newkey] = val
+        chamix = {}
+        for key in obj.blocks['UMIX'].entries:
+            val = obj.blocks['UMIX'].entries[key]
+            newkey = 'U'+str(key[0])+str(key[1])
+            chamix[newkey] = val
+        for key in obj.blocks['VMIX'].entries:
+            val = obj.blocks['VMIX'].entries[key]
+            newkey = 'V'+str(key[0])+str(key[1])
+            chamix[newkey] = val
+        stopmix = {}
+        for key in obj.blocks['STOPMIX'].entries:
+            val = obj.blocks['STOPMIX'].entries[key]
+            newkey = 'ST'+str(key[0])+str(key[1])
+            stopmix[newkey] = val
+        sbotmix = {}
+        for key in obj.blocks['SBOTMIX'].entries:
+            val = obj.blocks['SBOTMIX'].entries[key]
+            newkey = 'SB'+str(key[0])+str(key[1])
+            sbotmix[newkey] = val
+
+        return {'MINPAR': MINPAR, 'chimix': chimix, 'stopmix': stopmix,
+                'chamix': chamix, 'MM': {}, 'sbotmix': sbotmix,
+                'EXTPAR': EXTPAR, 'mass': mass}
+
+    def _formatUncovered(self, obj):
+        """
+        Format data of the Uncovered object containing coverage info
+
+        :param obj: An Uncovered object to be printed.
+        """
+
+        # Number of missing topologies to be printed (ordered by cross sections)
+        nprint = 10
+
+        uncoveredDict = {}
+        # First sort groups by label
+        groups = sorted(obj.groups[:], key=lambda g: g.label)
+        # Add summary of groups:
+        for group in groups:
+            sqrts = group.sqrts.asNumber(TeV)
+            uncoveredDict["Total xsec for %s (fb)" % group.description] = \
+                self._round(group.getTotalXSec())
+            uncoveredDict["%s" % group.description] = []
+            for fsSMS in group.finalStateSMS[:nprint]:
+                fsSMSDict = {'sqrts (TeV)': sqrts, 'weight (fb)': self._round(fsSMS.missingX)}
+
+                if self.outputFormat == 'version2':
+                    smsStr = fsSMS.oldStr()
+                    fsSMSDict['element'] = smsStr
+                else:
+                    smsStr = str(fsSMS)
+                    fsSMSDict['SMS'] = smsStr
+
+
+                if hasattr(self, "addsmslist") and self.addsmslist:
+                    if self.outputFormat == "version2":
+                        fsSMSDict["element IDs"] = [sms.smsID
+                                                for sms in fsSMS._contributingSMS]
+                    else:
+                        fsSMSDict["SMS IDs"] = [sms.smsID
+                                                for sms in fsSMS._contributingSMS]
+                uncoveredDict["%s" % group.description].append(fsSMSDict)
+
+        return uncoveredDict
+
+    def _formatTheoryPrediction(self,obj):
+        return self._formatTheoryPredictionsCombiner(obj)
+    
+    def _formatTheoryPredictionsCombiner(self, obj):
+        """
+        Format data of the TheoryPredictionsCombiner object.
+
+        :param obj: A TheoryPredictionsCombiner object to be printed.
+        """
+
+        combRes = []  # In case we have a list of combined results in the future
+
+        # Get list of analyses used in combination:
+        expIDs = obj.analysisId()
+        ul = obj.getUpperLimit()
+        ulExpected = obj.getUpperLimit(expected=True)
+        if isinstance(ul, unum.Unum):
+            ul = ul.asNumber(fb)
+        if isinstance(ulExpected, unum.Unum):
+            ulExpected = ulExpected.asNumber(fb)
+
+        r = self._round(obj.getRValue(expected=False))
+        r_expected = self._round(obj.getRValue(expected=True))
+
+        nll = self._round(obj.likelihood( return_nll = True ))
+        nllmin = self._round(obj.lmax( return_nll = True ))
+        nllsm = self._round(obj.lsm( return_nll = True ))
+
+        resDict = {'AnalysisID': expIDs,
+                   'r': r, 'r_expected': r_expected,
+                   'nll': nll,
+                   'nll_min': nllmin,
+                   'nll_SM': nllsm}
+
+        combRes.append(resDict)
+
+        return {'CombinedRes': combRes}
diff --git a/smodels/tools/printers/slhaPrinter.py b/smodels/tools/printers/slhaPrinter.py
new file mode 100644
index 000000000..1fc745622
--- /dev/null
+++ b/smodels/tools/printers/slhaPrinter.py
@@ -0,0 +1,234 @@
+"""
+.. module:: slhaPrinter
+   :synopsis: Class for describing a printer in SLHA format
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+
+"""
+
+from __future__ import print_function
+import os
+from smodels.matching.theoryPrediction import TheoryPredictionList,TheoryPrediction,TheoryPredictionsCombiner
+from smodels.tools.ioObjects import OutputStatus
+from smodels.tools.coverage import Uncovered
+from smodels.base.physicsUnits import GeV, fb, TeV
+from smodels.base.smodelsLogging import logger
+from smodels.tools.printers.txtPrinter import TxTPrinter
+import numpy as np
+import unum
+
+
+class SLHAPrinter(TxTPrinter):
+    """
+    Printer class to handle the printing of slha format summary output.
+    It uses the facilities of the TxTPrinter.
+    """
+
+    def __init__(self, output='file', filename=None, outputFormat='current'):
+        TxTPrinter.__init__(self, output, filename, outputFormat)
+        self.name = "slha"
+        self.docompress = 0
+        self.combinesr = 0
+        self.combineanas = 0
+        self.printingOrder = [OutputStatus, TheoryPredictionList,
+                              TheoryPredictionsCombiner, 
+                              TheoryPrediction, Uncovered]
+        self.toPrint = [None]*len(self.printingOrder)
+
+    def setOutPutFile(self, filename, overwrite=True, silent=False):
+        """
+        Set the basename for the text printer. The output filename will be
+        filename.smodels.
+        :param filename: Base filename
+        :param overwrite: If True and the file already exists, it will be removed.
+        :param silent: dont comment removing old files
+        """
+
+        self.filename = filename + '.smodelsslha'
+        if overwrite and os.path.isfile(self.filename):
+            if not silent:
+                logger.warning("Removing old output file " + self.filename)
+            os.remove(self.filename)
+
+    def _formatOutputStatus(self, obj):
+
+        smodelsversion = obj.smodelsVersion
+        if not smodelsversion.startswith("v"):
+            smodelsversion = "v" + smodelsversion
+
+        keysDict = {0: "%-25s #SModelS version\n" % (smodelsversion),
+                    1: "%-25s #database version\n" % (obj.databaseVersion.replace(" ", "")),
+                    2: "%-25s #maximum condition violation\n" % (obj.parameters['maxcond']),
+                    3: "%-25s #compression (0 off, 1 on)\n" % (self.docompress),
+                    4: "%-25s #minimum mass gap for mass compression [GeV]\n" % (obj.parameters['minmassgap']),
+                    5: "%-25s #sigmacut [fb]\n" % (obj.parameters['sigmacut']),
+                    6: "%-25s #signal region combination (0 off, 1 on)\n" % (self.combinesr),
+                    7: "%-25s #analyses combination (0 off, 1 on)\n" % (self.combineanas)}
+
+        if 'promptwidth' in obj.parameters:
+            keysDict[8] = "%-25s #prompt width [GeV] \n" % (obj.parameters['promptwidth'])
+        if 'stablewidth' in obj.parameters:
+            keysDict[9] = "%-25s #stable width [GeV] \n" % (obj.parameters['stablewidth'])
+
+        output = "BLOCK SModelS_Settings\n"
+        for key in sorted(list(keysDict.keys())):
+            output += " %i %s" % (key, keysDict[key])
+        output += '\n'
+
+        # for SLHA output we always want to have SModelS_Exclusion block, if no results we write it here
+        if obj.status <= 0:
+            output += "BLOCK SModelS_Exclusion\n"
+            output += " 0 0 %-30s #output status (-1 not tested, 0 not excluded, 1 excluded)\n\n" % (-1)
+
+        return output
+
+    def _formatTheoryPredictionList(self, obj):
+
+        printAll = True  # Controls which theory predictions are printed
+        if hasattr(self, "expandedoutput") and not self.expandedoutput:
+            printAll = False
+
+        output = "BLOCK SModelS_Exclusion\n"
+        if not obj._theoryPredictions[0]:
+            excluded = -1
+        else:
+            obj.sortTheoryPredictions()
+            firstResult = obj._theoryPredictions[0]
+            r = firstResult.getRValue()
+            excluded = 0
+            if r is not None and r > 1:
+                excluded = 1
+        output += " 0 0 %-30s #output status (-1 not tested, 0 not excluded, 1 excluded)\n" % (
+            excluded)
+        if excluded == -1:
+            rList = []
+        elif not printAll:
+            rList = [firstResult] + [res for res in obj._theoryPredictions[1:]
+                                   if (res.getRValue() is not None 
+                                       and res.getRValue() >= 1.0)]
+        else:
+            rList = obj._theoryPredictions[:]
+
+        for iTP, theoPred in enumerate(rList):
+            cter = iTP + 1
+            expResult = theoPred.expResult
+            txnames = theoPred.txnames
+            signalRegion = theoPred.dataId()
+            if signalRegion is None:
+                signalRegion = '(UL)'
+            r = theoPred.getRValue()
+            r_expected = theoPred.getRValue(expected=self.getTypeOfExpected())
+            txnameStr = str(sorted(list(set([str(tx) for tx in txnames]))))
+            txnameStr = txnameStr.replace(
+                "'", "").replace("[", "").replace("]", "")
+
+            output += " %d 0 %-30s #txname \n" % (cter, txnameStr)
+            if r is not None:
+                output += " %d 1 %-30.3E #r value\n" % (cter, r)
+            else:
+                output += " %d 1 NaN                            #r value (failed to compute r-value)\n" % (cter)
+            if not r_expected:
+                output += " %d 2 N/A                            #expected r value\n" % (cter) # r_expected could fail or simply not be available
+            else:
+                output += " %d 2 %-30.3E #expected r value\n" % (
+                    cter, r_expected)
+            output += " %d 3 %-30.2f #condition violation\n" % (
+                cter, theoPred.getmaxCondition())
+            output += " %d 4 %-30s #analysis\n" % (cter,
+                                                   expResult.globalInfo.id)
+            output += " %d 5 %-30s #signal region \n" % (
+                cter, signalRegion.replace(" ", "_"))
+            nll = theoPred.likelihood( return_nll  = True )
+            if nll is not None:
+                nllmin = theoPred.lmax(return_nll=True)
+                nllsm = theoPred.lsm( return_nll=True )
+                lvals = [nll, nllmin, nllsm]
+                for i, lv in enumerate(lvals):
+                    if isinstance(lv, (float, np.float64)):
+                        lv = "%-30.2E" % lv
+                    else:
+                        lv = str(lv)
+                    lvals[i] = lv
+                nll, nllmin, nllsm = lvals[:]
+                output += " %d 6 %s #nll\n" % (cter, nll)
+                output += " %d 7 %s #nll_min\n" % (cter, nllmin)
+                output += " %d 8 %s #nll_SM\n" % (cter, nllsm)
+            else:
+                output += " %d 6 N/A                            #nll\n" % (
+                    cter)
+                output += " %d 7 N/A                            #nll_min\n" % (
+                    cter)
+                output += " %d 8 N/A                            #nll_SM\n" % (
+                    cter)
+            output += "\n"
+
+        return output
+
+    def _formatUncovered(self, obj):
+
+        # First sort groups by label
+        groups = sorted(obj.groups[:], key=lambda g: g.label)
+        # Get summary of groups:
+        output = "\nBLOCK SModelS_Coverage"
+        for i, group in enumerate(sorted(groups, key=lambda g: g.label)):
+            output += "\n %d 0 %-30s      # %s" % (
+                i, group.label, group.description)
+            output += "\n %d 1 %-30.3E      # %s" % (
+                i, group.getTotalXSec(), "Total cross-section (fb)")
+        output += "\n"
+        return output
+
+    def _formatTheoryPrediction(self,obj):
+        return self._formatTheoryPredictionsCombiner(obj)
+
+    def _formatTheoryPredictionsCombiner(self, obj):
+        """
+        Format data of the TheoryPredictionsCombiner object.
+
+        :param obj: A TheoryPredictionsCombiner object to be printed.
+        """
+
+        output = "BLOCK SModelS_CombinedAnas\n"
+
+        combRes = [obj]  # For now use a dummy list (only a single combined result is expected)
+        for icomb, cRes in enumerate(combRes):
+            cter = icomb + 1
+            # Get list of analyses IDs used in combination:
+            expIDs = cRes.analysisId()
+            ul = cRes.getUpperLimit()
+            ulExpected = cRes.getUpperLimit(expected=True)
+            if isinstance(ul, unum.Unum):
+                ul = ul.asNumber(fb)
+            if isinstance(ulExpected, unum.Unum):
+                ulExpected = ulExpected.asNumber(fb)
+
+            r = self._round(cRes.getRValue(expected=False))
+            r_expected = self._round(cRes.getRValue(expected=True))
+
+            nll = cRes.likelihood(return_nll=True)
+            nllmin = cRes.lmax(return_nll=True)
+            nllsm = cRes.lsm(return_nll=True)
+            lvals = [nll, nllmin, nllsm]
+            for i, lv in enumerate(lvals):
+                if isinstance(lv, (float, np.float64)):
+                    lv = "%-30.2E" % lv
+                else:
+                    lv = str(lv)
+                lvals[i] = lv
+            nll, nllmin, nllsm = lvals[:]
+
+            if r is not None:
+                output += " %d 1 %-30.3E #r value\n" % (cter, r)
+            else:
+                output += " %d 1 NaN                            #r value (failed to compute r-value)\n" % (cter)
+            if r_expected is not None:
+                output += " %d 2 %-30.3E #expected r value\n" % (cter, r_expected)
+            else:
+                output += " %d 2 NaN                            #expected r value (failed to compute expected r-value)\n" % (cter)
+            output += " %d 3 %s #nll\n" % (cter, nll)
+            output += " %d 4 %s #nll_min\n" % (cter, nllmin)
+            output += " %d 5 %s #nll_SM\n" % (cter, nllsm)
+            output += " %d 6 %s #IDs of combined analyses\n" % (cter, expIDs)
+            output += "\n"
+
+        return output
diff --git a/smodels/tools/printers/summaryPrinter.py b/smodels/tools/printers/summaryPrinter.py
new file mode 100644
index 000000000..ffe8b6d32
--- /dev/null
+++ b/smodels/tools/printers/summaryPrinter.py
@@ -0,0 +1,190 @@
+"""
+.. module:: summaryPrinter
+   :synopsis: Class for describing a summary printer in text format.
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+
+"""
+
+from __future__ import print_function
+import os
+from smodels.matching.theoryPrediction import TheoryPredictionList,TheoryPrediction,TheoryPredictionsCombiner
+from smodels.tools.ioObjects import OutputStatus
+from smodels.tools.coverage import Uncovered
+from smodels.base.physicsUnits import fb, TeV
+from smodels.base.smodelsLogging import logger
+from smodels.tools.printers.txtPrinter import TxTPrinter
+import numpy as np
+import unum
+
+
+class SummaryPrinter(TxTPrinter):
+    """
+    Printer class to handle the printing of one single summary output.
+    It uses the facilities of the TxTPrinter.
+    """
+
+    def __init__(self, output='stdout', filename=None, outputFormat='current'):
+        TxTPrinter.__init__(self, output, filename, outputFormat)
+        self.name = "summary"
+        self.printingOrder = [
+            OutputStatus, TheoryPredictionList, 
+            TheoryPredictionsCombiner, 
+            TheoryPrediction, Uncovered]
+        self.toPrint = [None]*len(self.printingOrder)
+
+    def setOutPutFile(self, filename, overwrite=True, silent=False):
+        """
+        Set the basename for the text printer. The output filename will be
+        filename.smodels.
+        :param filename: Base filename
+        :param overwrite: If True and the file already exists, it will be removed.
+        :param silent: dont comment removing old files
+        """
+
+        self.filename = filename + '.smodels'
+        if overwrite and os.path.isfile(self.filename):
+            if not silent:
+                logger.warning("Removing old output file " + self.filename)
+            os.remove(self.filename)
+
+    def _formatTheoryPredictionList(self, obj):
+        """
+        Format data of the TheoryPredictionList object.
+
+        :param obj: A TheoryPredictionList object to be printed.
+        """
+        obj.sortTheoryPredictions()
+        if hasattr(self, "expandedsummary") and not self.expandedsummary:
+            theoPredictions = [obj._theoryPredictions[0]]
+        else:
+            theoPredictions = obj._theoryPredictions
+
+        output = ""
+
+        maxr = {"obs": -1., "exp": -1, "anaid": "?"}
+        maxcoll = {"CMS": {"obs": -1., "exp": -1, "anaid": "?"},
+                   "ATLAS": {"obs": -1., "exp": -1, "anaid": "?"}}
+        for theoPred in obj._theoryPredictions:
+            r = theoPred.getRValue(expected=False)
+            r_expected = theoPred.getRValue(expected=self.getTypeOfExpected())
+            expResult = theoPred.expResult
+            coll = "ATLAS" if "ATLAS" in expResult.globalInfo.id else "CMS"
+            if (r_expected is not None) and (r_expected > maxcoll[coll]["exp"]):
+                maxcoll[coll] = {"obs": r, "exp": r_expected,
+                                 "anaid": expResult.globalInfo.id}
+            if (r is not None) and (r > maxr["obs"]):
+                maxr = {"obs": r, "exp": r_expected,
+                        "anaid": expResult.globalInfo.id}
+
+        output += "#Analysis  Sqrts  Cond_Violation  Theory_Value(fb)  Exp_limit(fb)  r  r_expected"
+        output += "\n\n"
+        for theoPred in theoPredictions:
+            expResult = theoPred.expResult
+            txnames = theoPred.txnames
+            ul = theoPred.getUpperLimit(expected=False)
+            uls = str(ul)
+            if isinstance(ul, unum.Unum):
+                uls = "%10.3E" % ul.asNumber(fb)
+            signalRegion = theoPred.dataset.getID()
+            if signalRegion is None:
+                signalRegion = '(UL)'
+            value = theoPred.xsection
+            r = theoPred.getRValue(expected=False)
+            r_expected = theoPred.getRValue(expected=self.getTypeOfExpected())
+            if r is not None:
+                rs = "%10.3E" % r
+            else:
+                rs = "NaN" # r = None means the calculation failed
+            if r_expected is not None:
+                rs_expected = "%10.3E" % r_expected
+            else:
+                rs_expected = "N/A" # r_exp could not be available
+
+            output += "%19s  " % (expResult.globalInfo.id)  # ana
+            # output += "%4s " % (expResult.globalInfo.sqrts/ TeV)  # sqrts
+            # sqrts
+            output += "%2.2E  " % (expResult.globalInfo.sqrts.asNumber(TeV))
+            output += "%5s " % theoPred.getmaxCondition()  # condition violation
+            # theory cross section , expt upper limit
+            output += "%10.3E %s " % (value.asNumber(fb), uls)
+            output += "%s %s" % (rs, rs_expected)
+            
+            output += "\n"
+            output += " Signal Region:  "+signalRegion+"\n"
+            txnameStr = str(sorted(list(set([str(tx) for tx in txnames]))))
+            txnameStr = txnameStr.replace(
+                "'", "").replace("[", "").replace("]", "")
+            output += " Txnames:  " + txnameStr + "\n"
+            nll = theoPred.likelihood( return_nll = True )
+            if nll is not None:
+                nllmin = theoPred.lmax( return_nll = True )
+                nllsm = theoPred.lsm( return_nll = True )
+                lvals = [nll, nllmin, nllsm]
+                for i, lv in enumerate(lvals):
+                    if isinstance(lv, (float, np.float64)):
+                        lv = f"{lv:10.3E}"
+                    else:
+                        lv = str(lv)
+                    lvals[i] = lv
+                nll, nllmin, nllsm = lvals[:]
+                if nll == nllmin == nllsm == "None":
+                    output += " Likelihoods: nll, nll_min, nll_SM = N/A\n"
+                else:
+                    output += f" Likelihoods: nll, nll_min, nll_SM = {nll}, {nllmin}, {nllsm}\n"
+
+            if not (theoPred is obj[-1]):
+                output += 80 * "-" + "\n"
+
+        output += "\n \n"
+        output += 80 * "=" + "\n"
+        output += "The highest r value is = %.5f from %s" % \
+            (maxr["obs"], maxr["anaid"])
+        if maxr["exp"] is not None and maxr["exp"] >= 0.0:
+            output += " (r_expected=%.5f)" % maxr["exp"]
+        else:
+            output += " (r_expected not available)"
+        output += "\n"
+        for coll, values in maxcoll.items():
+            if values["obs"] == None or values["obs"] < 0.0:
+                continue
+            output += "%s analysis with highest available r_expected: %s, r_expected=%.5f, r_obs=%.5f\n" % \
+                      (coll, values["anaid"], values["exp"], values["obs"])
+
+        return output
+
+    def _formatTheoryPrediction(self,obj):
+        return self._formatTheoryPredictionsCombiner(obj)
+
+    def _formatTheoryPredictionsCombiner(self, obj):
+        """
+        Format data of the TheoryPredictionsCombiner object.
+
+        :param obj: A TheoryPredictionsCombiner object to be printed.
+        """
+
+        output = "===================================================== \n"
+
+        # Get list of analyses used in combination:
+        expIDs = obj.analysisId()
+        # Get r-value:
+        r = obj.getRValue()
+        r_expected = obj.getRValue(expected=True)
+        # Get likelihoods:
+        nllsm = obj.lsm( return_nll = True )
+        nll = obj.likelihood( return_nll = True )
+        nllmin = obj.lmax( return_nll = True )
+        output += f"Combined Analyses: {expIDs}\n"
+        output += f"Likelihoods: nll, nll_min, nll_SM = {nll:.3f}, {nllmin:.3f}, {nllsm:.3f}\n"
+        if r is not None:
+            output += f"combined r-value: {r:10.3E}\n"
+        else:
+            output += f"combined r-value: NaN (failed to compute r-value)\n"
+        if r_expected is not None:
+            output += f"combined r-value (expected): {r_expected:10.3E}\n"
+        else:
+            output += f"combined r-value (expected): NaN (failed to compute r-value)\n"
+        output += "\n===================================================== \n"
+        output += "\n"
+
+        return output
diff --git a/smodels/tools/printers/txtPrinter.py b/smodels/tools/printers/txtPrinter.py
new file mode 100644
index 000000000..5482569d1
--- /dev/null
+++ b/smodels/tools/printers/txtPrinter.py
@@ -0,0 +1,484 @@
+"""
+.. module:: txtPrinter
+   :synopsis: Class for defining a log (stdout) printer
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+"""
+
+import os
+from smodels.tools.printers.basicPrinter import BasicPrinter
+from smodels.decomposition.topologyDict import TopologyDict
+from smodels.matching.theoryPrediction import TheoryPredictionList,TheoryPrediction,TheoryPredictionsCombiner
+from smodels.experiment.databaseObj import Database
+from smodels.tools.ioObjects import OutputStatus
+from smodels.tools.coverage import Uncovered
+from smodels.base.physicsUnits import GeV, fb, TeV
+from smodels.base.smodelsLogging import logger
+import numpy as np
+from itertools import groupby
+import time
+
+class TxTPrinter(BasicPrinter):
+    """
+    Printer class to handle the printing of one single text output
+    """
+
+    def __init__(self, output='stdout', filename=None, outputFormat='current'):
+        BasicPrinter.__init__(self, output, filename, outputFormat)
+        self.name = "log"
+        self.printtimespent = False
+        self.printingOrder = [OutputStatus, Database, TopologyDict,
+                              TheoryPredictionList, TheoryPredictionsCombiner,
+                              TheoryPrediction, Uncovered]
+        self.toPrint = [None] * len(self.printingOrder)
+
+    def setOutPutFile(self, filename, overwrite=True, silent=False):
+        """
+        Set the basename for the text printer. The output filename will be
+        filename.log.
+
+        :param filename: Base filename
+        :param overwrite: If True and the file already exists, it will be removed.
+        :param silent: dont comment removing old files
+        """
+
+        self.filename = filename + '.' + self.name
+        if overwrite and os.path.isfile(self.filename):
+            if not silent:
+                logger.warning("Removing old output file " + self.filename)
+            os.remove(self.filename)
+
+    def _formatDoc(self, obj):
+
+        return False
+
+    def _formatOutputStatus(self, obj):
+        """
+        Format data for a OutputStatus object.
+
+        :param obj: A OutputStatus object to be printed.
+        """
+
+        output = ""
+        output += "Input status: " + str(obj.filestatus) + "\n"
+        # hidden feature, printtimespent, turn on in ini file, e.g.
+        # [summary-printer] printtimespent = True
+        if self.printtimespent:
+            output += "Time spent: %.2fs\n" % (time.time() - self.time)
+        output += "Decomposition output status: " + str(obj.status) + " "
+        st = "unknown status"
+        if obj.status in obj.statusStrings:
+            st = obj.statusStrings[obj.status]
+        output += st + "\n"
+        if obj.filestatus < 0:
+            output += str(obj.warnings) + "\n"
+        output += "# Input File: " + obj.inputfile + "\n"
+        labels = list(obj.parameters.keys())
+        labels.sort()
+        # for label, par in obj.parameters.items():
+        for label in labels:
+            par = obj.parameters[label]
+            output += "# " + label + " = " + str(par) + '\n'
+        if obj.smodelsVersion:
+            output += f"# SModelS version: {obj.smodelsVersion}\n"
+        if obj.databaseVersion:
+            output += f"# Database version: {obj.databaseVersion}\n"
+        output += "=" * 80 + "\n"
+        return output
+
+    def _formatTopologyDict(self, obj):
+        """
+        Format data for a TopologyDict object.
+
+        :param obj: A TopologyDict object to be printed.
+        """
+
+        if not hasattr(self, 'printdecomp') or not self.printdecomp:
+            return None
+        
+        slabel = "Topologies Table"
+        output = ""
+        output += "  " + "="*56 + "  \n"
+        output += "||" + " "*56 + "||\n"
+        xspace = int((56-len(slabel))/2.)
+        output += "||" + " "*xspace+slabel+" "*(56-xspace-len(slabel))+"||\n"
+        output += "||" + " "*56 + "||\n"
+        output += "  " + "="*56 + "  \n"
+
+        if self.outputFormat == "version2":
+            baseLabel = 'Element'
+        else:
+            baseLabel = 'SMS'
+
+        # Get topology names:
+        topoNames = {canonName : canonName for canonName in obj}
+        topoNames_v2 = {}
+        if self.outputFormat == "version2":            
+            for canonName in obj:
+                smsList = obj[canonName]       
+                try:
+                    sms = smsList[0]
+                    evenParticles = sms.treeToBrackets()[0]
+                    vertnumb = str([len(v) for v in evenParticles[0]])
+                    vertnumb += str([len(v) for v in evenParticles[1]])
+                    vertnumb = vertnumb.replace(' ','')
+                    topoName = vertnumb
+                    topoNames_v2[canonName] = topoName
+                except:
+                    logger.info("Could not format SMS using version2, switching to current format.")
+                    self.outputFormat = 'current'
+        
+        if self.outputFormat == 'version2':
+            topoNames = topoNames_v2
+
+        for canonName in obj:
+            smsList = obj[canonName]
+            topoName = topoNames[canonName]
+
+            output += "===================================================== \n"
+            output += "Topology: %s \n" %topoName
+            totxsec = smsList[0].weightList
+            for sms in smsList[1:]:
+                totxsec += sms.weightList
+
+            output += "Total Global topology weight :\n" + totxsec.niceStr() + '\n'
+            output += "Total Number of %s: " %baseLabel + \
+                str(len(smsList)) + '\n'
+            if not hasattr(self, 'addsmsinfo') or not self.addsmsinfo:
+                continue
+            for sms in smsList:
+                output += "\t\t " + 73 * "." + "\n"
+                output += self._formatSMS(sms) + "\n"
+
+        return output
+
+    def _formatSMS(self, obj):
+        """
+        Format data for an SMS object.
+
+        :param obj: SMS object to be printed.
+        """
+
+        output = ""
+
+        if self.outputFormat == 'version2':
+            output += "\t\t Element: \n"
+            branchList, finalState, _ = obj.treeToBrackets()
+            masses = []
+            pidlist = []
+            for bIndex in obj.daughterIndices(obj.rootIndex):
+                branch = obj.indexToNode(bIndex)
+                if branch.isSM:
+                    continue
+                bMasses = [branch.mass]
+                pids = [branch.pdg]
+                for n in obj.dfsIndexIterator(bIndex):
+                    node = obj.indexToNode(n)
+                    if node.isSM:
+                        continue
+                    bMasses.append(node.mass)
+                    pids.append(node.pdg)
+                masses.append(bMasses)
+                pidlist.append(pids)
+            # Sort pidlist for consistent output
+            pidlist = sorted(pidlist, key = lambda x: str(x))
+
+            output += "\t\t Element ID: " + str(obj.smsID)
+            output += "\n"
+            output += "\t\t Particles in element: " + str(branchList).replace("'","").replace(" ","")
+            output += "\n"
+            output += "\t\t Final states in element: " + str(finalState).replace("'","").replace(" ","")
+            output += "\n"
+            output += "\t\t The element masses are \n"
+            for i, mass in enumerate(masses):
+                output += "\t\t Branch %i: " % i + str(mass) + "\n"
+            output += "\n"
+            output += "\t\t The element PIDs are \n"
+            pidstr = sorted([str(p) for p in pidlist])
+            output += "\t\t PIDs: " + str(pidlist) + "\n"
+            output += "\t\t The element weights are: \n \t\t " + \
+                obj.weightList.niceStr().replace("\n", "\n \t\t ")
+
+        else:
+            output += "\t\t SMS ID: %i\n" %obj.smsID
+            output += "\t\t SMS: %s\n" %str(obj)
+            output += "\t\t Masses: %s\n" %str([(node,mass) for node,mass in zip(obj.nodes,obj.mass)
+                                                if not node.isSM and not node is obj.root])
+            output += "\t\t Cross-Sections:\n \t\t "+obj.weightList.niceStr().replace("\n", "\n \t\t ")
+
+        return output
+
+    def _formatDatabase(self, obj):
+        """
+        Format data for a Database object.
+
+        :param obj: A Database object to be printed.
+        """
+
+        if not hasattr(self, "printdatabase") or not self.printdatabase:
+            return None
+
+        expResults = obj.expResultList
+        slabel = "Selected Experimental Results"
+        output = ""
+        output += "  " + "="*56 + "  \n"
+        output += "||" + " "*56 + "||\n"
+        xspace = int((56-len(slabel))/2.)
+        output += "||" + " "*xspace+slabel+" "*(56-xspace-len(slabel))+"||\n"
+        output += "||" + " "*56 + "||\n"
+        output += "  " + "="*56 + "  \n"
+
+        for expRes in expResults:
+            output += self._formatExpResult(expRes)
+
+        return output+"\n"
+
+    def _formatExpResult(self, obj):
+        """
+        Format data for a ExpResult object.
+
+        :param obj: A ExpResult object to be printed.
+        """
+
+        if self.outputFormat == "version2":
+            baseLabel = 'Elements'
+        else:
+            baseLabel = 'SMS'
+
+
+        txnames = []
+        for dataset in obj.datasets:
+            for txname in dataset.txnameList:
+                tx = txname.txName
+                if tx not in txnames:
+                    txnames.append(tx)
+
+        txnames = sorted(txnames)
+        output = ""
+        output += "========================================================\n"
+        output += "Experimental Result ID: " + obj.globalInfo.id + '\n'
+        output += "Tx Labels: " + str(txnames) + '\n'
+        output += "Sqrts: %2.2E\n" % obj.globalInfo.sqrts.asNumber(TeV)
+        if hasattr(self, "addanainfo") and self.addanainfo:
+            output += "\t -----------------------------\n"
+            output += "\t %s tested by analysis:\n" %baseLabel
+            listOfSMS = []
+            for dataset in obj.datasets:
+                for txname in dataset.txnameList:
+                    for sms in txname.smsMap:
+                        if self.outputFormat == 'version2':
+                            smsStr = str(sms.treeToBrackets()[0])
+                            smsStr = smsStr.replace("'","").replace(" ","")
+                        else:
+                            smsStr = str(sms)
+                        if smsStr not in listOfSMS:
+                            listOfSMS.append(smsStr)
+            for sms in listOfSMS:
+                output += "\t    %s \n" %sms
+
+        return output
+
+    def _formatNumber(self, number, n=4):
+        """ format a number <number> to have n digits,
+            but allow also for None, strings, etc """
+        if type(number) not in [float, np.float64]:
+            return str(number)
+        fmt = ".%dg" % n
+        return ("%"+fmt) % number
+
+    def _formatTheoryPredictionList(self, obj):
+        """
+        Format data for a TheoryPredictionList object.
+
+        :param obj: A TheoryPredictionList object to be printed.
+        """
+
+        if self.outputFormat == "version2":
+            baseLabel = 'Elements'
+        else:
+            baseLabel = 'SMS'
+
+
+        slabel = "Theory Predictions and"
+        output = ""
+        output += "  " + "="*56 + "  \n"
+        output += "||" + " "*56 + "||\n"
+        xspace = int((56-len(slabel))/2.)
+        output += "||" + " "*xspace+slabel+" "*(56-xspace-len(slabel))+"||\n"
+        slabel = "Experimental Constraints"
+        xspace = int((56-len(slabel))/2.)
+        output += "||" + " "*xspace+slabel+" "*(56-xspace-len(slabel))+"||\n"
+        output += "||" + " "*56 + "||\n"
+        output += "  " + "="*56 + "  \n"
+
+        for theoryPrediction in obj._theoryPredictions:
+            expRes = theoryPrediction.expResult
+            dataId = theoryPrediction.dataId()
+            txnames = [str(txname) for txname in theoryPrediction.txnames]
+            txnames = sorted(list(set(txnames)))
+            output += "\n"
+            output += "---------------Analysis Label = " + expRes.globalInfo.id + "\n"
+            output += "-------------------Dataset Label = " + \
+                str(dataId).replace("None", "(UL)") + "\n"
+            output += "-------------------Txname Labels = " + \
+                str(txnames) + "\n"
+            output += "Analysis sqrts: " + str(expRes.globalInfo.sqrts) + \
+                "\n"
+
+            output += "Theory prediction: " + \
+                str(theoryPrediction.xsection) + "\n"
+            output += "Theory conditions:"
+            output += "  " + str(theoryPrediction.conditions) + "\n"
+
+            # Get upper limit for the respective prediction:
+            upperLimit = theoryPrediction.getUpperLimit(expected=False)
+            upperLimitExp = theoryPrediction.getUpperLimit(
+                expected=self.getTypeOfExpected())
+
+            output += "Observed experimental limit: " + str(upperLimit) + "\n"
+            if upperLimitExp is not None:
+                output += "Expected experimental limit: " + \
+                    str(upperLimitExp) + "\n"
+            srv = self._formatNumber(
+                theoryPrediction.getRValue(expected=False), 4)
+            output += "Observed r-value: %s\n" % srv
+            if upperLimitExp is not None:
+                serv = self._formatNumber(theoryPrediction.getRValue(
+                    expected=self.getTypeOfExpected()), 4)
+                output += "Expected r-value: %s\n" % serv
+            nll = theoryPrediction.likelihood( return_nll = True )
+            if nll is not None:
+                chi2, chi2sm = None, None
+                nllsm = theoryPrediction.lsm( return_nll = True )
+                nllmin = theoryPrediction.lmax( return_nll = True )
+                try:
+                    # chi2sm = -2*np.log(llhd/theoryPrediction.lsm())
+                    chi2sm = 2*(nll - nllsm )
+                except TypeError:
+                    pass
+                try:
+                    # chi2 = -2*np.log(llhd/theoryPrediction.lmax())
+                    chi2 = 2*(nll - nllmin )
+                except TypeError:
+                    pass
+                output += "nll: " + self._formatNumber(nll, 4) + "\n"
+                output += "nll_min: " + self._formatNumber(nllmin, 4) + \
+                          "   -2log(L/L_max): " + self._formatNumber(chi2, 4) + "\n"
+                output += "nll_SM: " + self._formatNumber(nllsm, 4) + \
+                          "   -2log(L/L_SM): " + \
+                    self._formatNumber(chi2sm, 4) + "\n"
+
+            if hasattr(self, "printextendedresults") and self.printextendedresults:
+                if theoryPrediction.mass:
+                    for ibr, br in enumerate(theoryPrediction.mass):
+                        output += "Masses in branch %i: " % ibr + \
+                            str(br) + "\n"
+                IDList = list(
+                    set([sms.smsID for sms in theoryPrediction.smsList]))
+                if IDList:
+                    output += "Contributing %s: " %baseLabel + str(IDList) + "\n"
+
+                if self.outputFormat == 'version2':
+                    smsPIDs = []
+                    for sms in theoryPrediction.smsList:
+                        pidList = []
+                        for bIndex in sms.daughterIndices(sms.rootIndex):
+                            pids = [sms.indexToNode(bIndex).pdg]
+                            for nodeIndex in sms.dfsIndexIterator(bIndex):
+                                node = sms.indexToNode(nodeIndex)
+                                if node.isSM:
+                                    continue
+                                pids.append(node.pdg)
+                            pidList.append(pids)
+                        if pidList not in smsPIDs:
+                            smsPIDs.append(pidList)
+                    for pidList in smsPIDs:
+                        # Sort pidlist for consistent output
+                        pidList = sorted(pidList, key = lambda x: str(x))
+                        output += "PIDs:" + str(pidList) + "\n"
+
+        return output
+
+    def _formatUncovered(self, obj):
+        """
+        Format all uncovered data.
+
+        :param obj: Uncovered object to be printed.
+        """
+
+        if self.outputFormat == "version2":
+            baseLabel = 'Element'
+        else:
+            baseLabel = 'SMS'
+
+
+        # Number of missing topologies to be printed (ordered by cross sections)
+        nprint = 10
+
+        # First sort groups by label
+        groups = sorted(obj.groups[:], key=lambda g: g.label)
+        # Get summary of groups:
+        output = "\n"
+        for group in groups:
+            output += "Total cross-section for %s (fb): %10.3E\n" % (
+                group.description, group.getTotalXSec())
+
+        output += "\n#Full information on unconstrained cross sections\n"
+        output += "================================================================================\n"
+
+        # Get detailed information:
+        for group in groups:
+            description = group.description
+            sqrts = group.sqrts.asNumber(TeV)
+            if not group.finalStateSMS:
+                output += "No %s found\n" % description
+                output += "================================================================================\n"
+                continue
+            output += "%s with the highest cross sections (up to %i):\n" % (
+                description, nprint)
+            output += "Sqrts (TeV)   Weight (fb)                  %s description\n" %baseLabel
+            for fsSMS in group.finalStateSMS[:nprint]:
+                if self.outputFormat == 'version2':
+                    smsStr = fsSMS.oldStr()
+                else:
+                    smsStr = str(fsSMS)
+
+                output += "%5s         %10.3E    # %53s \n" % (
+                    str(sqrts), fsSMS.missingX, smsStr)
+                if hasattr(self, "addcoverageid") and self.addcoverageid:
+                    contributing = []
+                    for sms in fsSMS._contributingSMS:
+                        contributing.append(sms.smsID)
+                    output += "Contributing %s %s\n" %(baseLabel,str(contributing))
+            output += "================================================================================\n"
+        return output
+
+    def _formatTheoryPrediction(self,obj):
+        return self._formatTheoryPredictionsCombiner(obj)
+
+    def _formatTheoryPredictionsCombiner(self, obj):
+        """
+        Format data of the TheoryPredictionsCombiner object.
+
+        :param obj: A TheoryPredictionsCombiner object to be printed.
+        """
+
+        output = "===================================================== \n"
+
+        # Get list of analyses used in combination:
+        expIDs = obj.analysisId()
+        # Get r-value:
+        r = self._formatNumber(obj.getRValue(),4)
+        r_expected = self._formatNumber(obj.getRValue(expected=self.getTypeOfExpected()),4)
+        # Get likelihoods:
+        nllsm = obj.lsm( return_nll = True )
+        nll = obj.likelihood( return_nll = True )
+        nllmin = obj.lmax( return_nll = True )
+        output += f"Combined Analyses: {expIDs}\n"
+        output += f"Likelihoods: nll, nll_min, nll_SM = {nll:.3f}, {nllmin:.3f}, {nllsm:.3f}\n" 
+        output += f"combined r-value: {r:s}\n"
+        output += f"combined r-value (expected): {r_expected:s}"
+        output += "\n===================================================== \n"
+        output += "\n"
+
+        return output
diff --git a/smodels/tools/printers/xmlPrinter.py b/smodels/tools/printers/xmlPrinter.py
new file mode 100644
index 000000000..e9734cb18
--- /dev/null
+++ b/smodels/tools/printers/xmlPrinter.py
@@ -0,0 +1,115 @@
+"""
+.. module:: xmlPrinter
+   :synopsis: Class for describing a printer in XML format
+
+.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
+
+"""
+
+from __future__ import print_function
+import sys
+import os
+import copy
+from smodels.decomposition.topologyDict import TopologyDict
+from smodels.matching.theoryPrediction import TheoryPredictionList,TheoryPrediction,TheoryPredictionsCombiner
+from smodels.tools.ioObjects import OutputStatus
+from smodels.tools.coverage import Uncovered
+from smodels.base.physicsUnits import GeV, fb, TeV
+from smodels.base.smodelsLogging import logger
+from smodels.tools.printers.pythonPrinter import PyPrinter
+import numpy as np
+from collections import OrderedDict
+from xml.dom import minidom
+from xml.etree import ElementTree
+import unum
+import time
+
+
+class XmlPrinter(PyPrinter):
+    """
+    Printer class to handle the printing of one single XML output
+    """
+
+    def __init__(self, output='stdout', filename=None, outputFormat='current'):
+        PyPrinter.__init__(self, output, filename, outputFormat)
+        self.name = "xml"
+        self.printingOrder = [OutputStatus, TopologyDict,
+                              TheoryPredictionList, TheoryPredictionsCombiner,
+                              TheoryPrediction, Uncovered]
+        self.toPrint = [None]*len(self.printingOrder)
+
+    def setOutPutFile(self, filename, overwrite=True, silent=False):
+        """
+        Set the basename for the text printer. The output filename will be
+        filename.xml.
+        :param filename: Base filename
+        :param overwrite: If True and the file already exists, it will be removed.
+        :param silent: dont comment removing old files
+        """
+
+        self.filename = filename + '.xml'
+        if overwrite and os.path.isfile(self.filename):
+            if not silent:
+                logger.warning("Removing old output file " + self.filename)
+            os.remove(self.filename)
+
+    def convertToElement(self, pyObj, parent, tag=""):
+        """
+        Convert a python object (list,dict,string,...)
+        to a nested XML element tree.
+        :param pyObj: python object (list,dict,string...)
+        :param parent: XML Element parent
+        :param tag: tag for the daughter element
+        """
+
+        tag = tag.replace(" ", "_").replace("(", "").replace(")", "")
+        if not isinstance(pyObj, list) and not isinstance(pyObj, dict):
+            parent.text = str(pyObj).lstrip().rstrip()
+        elif isinstance(pyObj, dict):
+            for key, val in sorted(pyObj.items()):
+                key = key.replace(" ", "_").replace("(", "").replace(")", "")
+                newElement = ElementTree.Element(key)
+                self.convertToElement(val, newElement, tag=key)
+                parent.append(newElement)
+        elif isinstance(pyObj, list):
+            parent.tag += '_List'
+            for val in pyObj:
+                newElement = ElementTree.Element(tag)
+                self.convertToElement(val, newElement, tag)
+                parent.append(newElement)
+
+    def flush(self):
+        """
+        Get the python dictionaries generated by the object formatting
+        to the defined output and convert to XML
+        """
+
+        outputDict = {}
+        for obj in self.toPrint:
+            if obj is None:
+                continue
+            output = self._formatObj(obj)  # Convert to python dictionaries
+            if not output:
+                continue  # Skip empty output
+            outputDict.update(output)
+
+        root = None
+        # Convert from python dictionaries to xml:
+        if outputDict:
+            root = ElementTree.Element('smodelsOutput')
+            self.convertToElement(outputDict, root)
+            rough_xml = ElementTree.tostring(root, 'utf-8')
+            nice_xml = minidom.parseString(
+                rough_xml).toprettyxml(indent="    ")
+            if self.output == 'stdout':
+                sys.stdout.write(nice_xml)
+            elif self.output == 'file':
+                if not self.filename:
+                    logger.error('Filename not defined for printer')
+                    return False
+                with open(self.filename, "a") as outfile:
+                    outfile.write(nice_xml)
+                    outfile.close()
+
+        self.toPrint = [None]*len(self.printingOrder)
+        return root
-- 
2.48.1

